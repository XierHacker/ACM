排序的意思很简单,就是讲无序的序列排成有序的序列,这个顺序是你自己定义的.
一般来说,接下来不做特殊说明,都是按照元素从小到大来排序做范例.
## 1.1 稳定性
稳定性的概念很简单,要是在一个序列里面有两个相同的元素,这里假设是`50(a)`和`50(b)`,这里括号中的a和b视为了区分这两个相同的元素.
稳定性的排序是指,经过排序之后,`50(a)`还是在`50(b)`的前面.而不稳定的排序是指,`50(a)`不在`50(b)`的前面.

## 1.2 排序算法分类
- **插入类**:在一个有序的序列中,插入一个新的记录.
属于这类排序的有`直接插入排序`,`折半插入排序`,`希尔排序`

- **交换类**:交换排序的核心是交换,即每一趟排序,都通过一系列的交换动作.属于这类排序的有
`冒泡排序`,`快速排序`等等

- **选择类**:选择排序在每一趟排序中会选出一个最小(或最大)的记录,把它和序列中的第一个或者最后一个交换.
属于这类排序的有`简单选择排序`,`堆排序`.

- **归并类**:归并排序就是将两个或者两个以上的有序序列合成一个新的有序序列.

- **基数类**:


# 二.插入类排序
插入排序思想很简单,就是直接从前到后,找到合适位置插入,找位置插入的时候,意味着某些元素向后移动.


![](https://upload-images.jianshu.io/upload_images/7885600-72dc0fc73e252b7e.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
## Ⅰ.直接插入排序
```c++
/*插入类排序*/
//直接插入排序,返回一个拍好序的序列
std::vector<int> insert_sort(const std::vector<int>& v)
{
    std::vector<int> temp=v;
    int storage; //暂存元素
    //从第二个元素开始,因为第一个元素是有序的
    for(int i=1;i<temp.size();i++)
    {
        storage=temp[i];
        int j=i-1;
        //在前面"有序"的部分移动元素(为了插入)
        while(j>=0&&storage<temp[j])
        {
            temp[j+1]=temp[j];
            --j;
        }
        //把存的数放到应该的位置(插入)
        temp[j+1]=storage;
    }
    return temp;
}
```
### 性能分析
时间:
- 最坏:整个序列是逆序,意味着`temp[j+1]=temp[j];`总是被执行.执行次数为`n(n-1)/2`
- 最好:整个序列有序,双层循环变为单层循环,执行次数为`n`
平均为O(n^2)

空间:
- 辅助存储空间不随着排序序列规模变化,为常亮,因此是O(1)




## Ⅱ.折半插入排序

# 三.交换类排序
## Ⅰ.冒泡排序
冒泡排序是通过一系列的交换动作来完成排序的.首先第一个记录和第二个记录比较,
要是第一个大,那么二者交换,否则不交换;然后第二个记录和第三个记录比较,要是第二个大,
那么二者交换,否则不交换.....一直到这一趟完成,最终最大的那个就被交换到了最后.
再在前面无需的部分继续再来一次.最后整个序列有序.

>冒泡排序算法结束的条件是在一趟排序过程中没有发生元素的交换.

代码:
```c++
//冒泡排序
std::vector<int> bubble_sort(const std::vector<int>& v)
{
    auto temp=v;
    int flag; //用来标识是否发生了交换
    for(int i=temp.size()-1;i>1;i--)
    {
        flag=0;
        //从前到后比较
        for(int j=0;j<i;j++)
        {
            if(temp[j]>temp[j+1])
            {
                //交换元素
                std::swap(temp[j],temp[j+1]);
                flag=1;
            }
        }
        //要是一次都没有交换
        if(flag==0)
            return temp;
    }
}
```
### 算法分析
- 



## Ⅱ.快速排序
代码:
```c++
//快速排序
//快速排序
void quick_sort(std::vector<int>& v,int left,int right) //对从v[left]到v[right]的元素进行排序
{
    //边界条件
    if(left>=right) {return ;}

    int temp;
    int i=left,j=right;
    temp=v[left];
    while(i<j)
    {
        while((i<j)&&(v[j]>temp))   {--j;}   //从右边往左边扫描找到一个小于temp的元素
        if(i<j)         //这里很重要的一点就是随时保证i<j这个大小关系
        {
            v[i]=v[j];      //把v[j]放到左边去了
            ++i;
        }
        while((i<j)&&(v[i]<temp))   {++i;}   //从左边往右边扫描找到一个大于temp的元素
        if(i<j)          //这里很重要的一点就是随时保证i<j这个大小关系
        {
            v[j]=v[i];      //把v[i]放到右边去了
            --j;
        }
    }

    //这个时候i==j,跳出循环,并且把temp放在最终位置
    v[i]=temp;
    quick_sort(v,left,i-1);     //递归对temp左边的元素进行排序
    quick_sort(v,i+1,right);    //递归对temp右边元素进行排序
}
```

# 四.选择类排序
## Ⅰ.简单选择排序
简单选择排序的思想很简单,首先从无序的序列中选择一个最小的,然后把最小的和第一个元素交换.对于剩下的无序部分,
选择最小的,然后和无序部分的第一个元素交换.一直到到最后就行了.

也就是说,不停在无序部分中选择最小的,把最小的放在前面去.
下面是一种简单的C++实现,其中有些STL特性很方便.
```c++
//简单选择排序法
std::vector<int> select_sort(const std::vector<int>& v)
{
    auto temp=v;
    for(int i=0;i<temp.size();i++)
    {
        //找无序中的最小值
        std::vector<int>::iterator min_itor=std::min_element(temp.begin()+i,temp.end());
        //把最小值与无序部分第一个元素(就是i索引的元素)交换
        std::swap(*min_itor,*(temp.begin()+i));
    }
    return temp;
}
```


## Ⅱ.堆排序
首先来说堆的概念,可以把堆看做是一种特殊的完全二叉树,这棵完全二叉树满足:
任何一个非叶结点的值都不大于(或者不小于)其左右孩子结点的值.

>**大顶堆**:父亲大,孩子小.

>**小顶堆**:父亲小,孩子大.

那么怎么能够从堆来排序呢?根据堆的定义知道,**代表堆的这棵完全二叉树的根节点的值是最大(或是最小的)**
.所以**将一个无序序列调整为一个堆**,就可以找出这个序列的最大(最小)值,然后将找到的这个值交换到序列的最后(或者最前),
这样有序序列元素增加一个,无序序列元素减少一个.不停的对新的无序序列重复这样的操作.就实现了排序.

在更加具体地来讲堆排序之前,先要说一下完全二叉树的顺序存储方式,即用**数组来存储一个完全二叉树**.

将完全二叉树中的结点按照编号依次放入一个一维数组里面,那么就完成了一棵完全二叉树的存储.
比如一个节点的编号为`i`,要是`2i`不大于`n`,那么i的左孩子就存储在`[2*i]`的位置.






Ⅲ
Ⅳ
Ⅴ
# 五.二路归并排序
# 六.基数排序
# 七.总结